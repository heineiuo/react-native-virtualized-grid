{"version":3,"sources":["src/Cell.tsx","src/VirtualGridUtils.tsx","src/VirtualizedGrid.tsx","App.tsx"],"names":["Cell","forwardRef","ref","renderCell","column","row","coordinate","useState","rowIndex","columnIndex","data","setData","useImperativeHandle","update","Animated","View","style","position","width","widthAnimated","height","heightAnimated","transform","translateX","add","xAnimated","x","translateY","yAnimated","y","ColumnObject","move","event","nextX","Math","min","max","minX","deltaX","nextY","minY","deltaY","setValue","this","Value","containerWidthAnimated","containerHeightAnimated","contentWidthAnimated","contentHeightAnimated","minXAnimated","subtract","minYAnimated","JSON","parse","stringify","RowObject","CellObject","createRef","VirtualizedGrid","columnCount","rowCount","getColumnWidth","getRowHeight","showColumnLine","showRowLine","view","useRef","layoutCount","setLayoutCount","virtualColumns","virtualRows","virtualCells","ValueXY","containerSize","getRange","useCallback","minColumn","current","maxColumn","minRow","maxRow","i","length","onContainerLayout","layout","nativeEvent","virtualColumnsTotalWidth","virtualRowsTotalHeight","rowHeight","push","prev","columnWidth","prevRow","prevColumn","j","updateCoordinate","containerWidth","containerHeight","shouldSplitAction","splitAction","finalMaxColumnIndex","deltaX0","finalMaxRowIndex","deltaY0","outsideColumns","outsideRows","outsideCells","console","error","unshift","cell","includes","requestAnimationFrame","onWheel","useEffect","Platform","OS","el","addEventListener","removeEventListener","overflow","onLayout","map","index","backgroundColor","App","useWindowDimensions","Number","MAX_SAFE_INTEGER","borderWidth","borderColor","info","flex","borderTopWidth","borderLeftWidth","padding","Text"],"mappings":"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","file":"static/js/app.f4ecf7ee.chunk.js","sourcesContent":["import { forwardRef, ReactNode, useImperativeHandle, useState } from \"react\";\nimport { Animated } from \"react-native\";\n\nimport { CellMethods } from \"./VirtualGridTypes\";\nimport { ColumnObject, RowObject } from \"./VirtualGridUtils\";\n\nexport const Cell = forwardRef<\n  CellMethods,\n  {\n    coordinate: Animated.AnimatedValueXY;\n    column: ColumnObject;\n    row: RowObject;\n    renderCell: (info: { columnIndex: number; rowIndex: number }) => ReactNode;\n  }\n>(({ renderCell, column, row, coordinate }, ref) => {\n  const [data, setData] = useState({\n    rowIndex: row.rowIndex,\n    columnIndex: column.columnIndex,\n  });\n\n  useImperativeHandle(\n    ref,\n    () => {\n      return {\n        update: (data) => {\n          setData(data);\n        },\n      } as CellMethods;\n    },\n    []\n  );\n\n  return (\n    <Animated.View\n      style={{\n        position: \"absolute\",\n        width: column.widthAnimated,\n        height: row.heightAnimated,\n        transform: [\n          { translateX: Animated.add(column.xAnimated, coordinate.x) },\n          { translateY: Animated.add(row.yAnimated, coordinate.y) },\n        ],\n      }}\n    >\n      {renderCell(data)}\n    </Animated.View>\n  );\n});\n","import { createRef, RefObject } from \"react\";\nimport { Animated } from \"react-native\";\n\nimport { CellMethods } from \"./VirtualGridTypes\";\n\nexport class CoordinateObject {\n  constructor() {\n    this.xAnimated = new Animated.Value(0);\n    this.yAnimated = new Animated.Value(0);\n    this.containerWidthAnimated = new Animated.Value(0);\n    this.containerHeightAnimated = new Animated.Value(0);\n    this.contentWidthAnimated = new Animated.Value(0);\n    this.contentHeightAnimated = new Animated.Value(0);\n    this.minXAnimated = Animated.subtract(\n      this.containerWidthAnimated,\n      this.contentWidthAnimated\n    );\n    this.minYAnimated = Animated.subtract(\n      this.containerWidthAnimated,\n      this.contentWidthAnimated\n    );\n  }\n\n  xAnimated: Animated.Value;\n  yAnimated: Animated.Value;\n  minXAnimated: Animated.AnimatedSubtraction;\n  minYAnimated: Animated.AnimatedSubtraction;\n  containerWidthAnimated: Animated.Value;\n  containerHeightAnimated: Animated.Value;\n  contentWidthAnimated: Animated.Value;\n  contentHeightAnimated: Animated.Value;\n\n  move = (event: WheelEvent) => {\n    const nextX = Math.min(0, Math.max(this.minX, this.x - event.deltaX));\n    const nextY = Math.min(0, Math.max(this.minY, this.y - event.deltaY));\n\n    this.xAnimated.setValue(nextX);\n    this.yAnimated.setValue(nextY);\n  };\n\n  get minX(): number {\n    return JSON.parse(JSON.stringify(this.minXAnimated));\n  }\n  get minY(): number {\n    return JSON.parse(JSON.stringify(this.minYAnimated));\n  }\n\n  get x(): number {\n    return JSON.parse(JSON.stringify(this.xAnimated));\n  }\n  get y(): number {\n    return JSON.parse(JSON.stringify(this.yAnimated));\n  }\n  get contentWidth(): number {\n    return JSON.parse(JSON.stringify(this.contentWidthAnimated));\n  }\n  get contentHeight(): number {\n    return JSON.parse(JSON.stringify(this.contentHeightAnimated));\n  }\n  get containerWidth(): number {\n    return JSON.parse(JSON.stringify(this.containerWidthAnimated));\n  }\n  get containerHeight(): number {\n    return JSON.parse(JSON.stringify(this.containerHeightAnimated));\n  }\n}\n\nexport class ColumnObject {\n  constructor({\n    x,\n    width,\n    columnIndex,\n  }: {\n    x: number;\n    width: number;\n    columnIndex: number;\n  }) {\n    this.xAnimated = new Animated.Value(x);\n    this.widthAnimated = new Animated.Value(width);\n    this.columnIndex = columnIndex;\n  }\n\n  columnIndex: number;\n  xAnimated: Animated.Value;\n  widthAnimated: Animated.Value;\n\n  get x(): number {\n    return JSON.parse(JSON.stringify(this.xAnimated));\n  }\n  get width(): number {\n    return JSON.parse(JSON.stringify(this.widthAnimated));\n  }\n}\n\nexport class RowObject {\n  constructor({\n    y,\n    height,\n    rowIndex,\n  }: {\n    y: number;\n    height: number;\n    rowIndex: number;\n  }) {\n    this.yAnimated = new Animated.Value(y);\n    this.heightAnimated = new Animated.Value(height);\n    this.rowIndex = rowIndex;\n  }\n\n  rowIndex: number;\n  yAnimated: Animated.Value;\n  heightAnimated: Animated.Value;\n\n  get y(): number {\n    return JSON.parse(JSON.stringify(this.yAnimated));\n  }\n\n  get height(): number {\n    return JSON.parse(JSON.stringify(this.heightAnimated));\n  }\n}\n\nexport class CellObject {\n  constructor({ column, row }: { column: ColumnObject; row: RowObject }) {\n    this.column = column;\n    this.row = row;\n    this.ref = createRef();\n  }\n\n  ref: RefObject<CellMethods>;\n  column: ColumnObject;\n  row: RowObject;\n\n  get x() {\n    return this.column.x;\n  }\n\n  get y() {\n    return this.row.y;\n  }\n\n  get width() {\n    return this.column.width;\n  }\n  get height() {\n    return this.row.height;\n  }\n}\n","import {\n  Fragment,\n  ReactNode,\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\";\nimport { Animated, Platform, View, ViewStyle } from \"react-native\";\n\nimport { Cell } from \"./Cell\";\nimport { CellObject, ColumnObject, RowObject } from \"./VirtualGridUtils\";\n\nexport function VirtualizedGrid({\n  style,\n  columnCount,\n  rowCount,\n  renderCell,\n  getColumnWidth = () => 100,\n  getRowHeight = () => 40,\n  showColumnLine = false,\n  showRowLine = false,\n}: {\n  style?: ViewStyle;\n  defaultColumnWidth?: number;\n  defaultRowHeight?: number;\n  columnCount: number;\n  rowCount: number;\n  showRowLine?: boolean;\n  showColumnLine?: boolean;\n  getColumnWidth?: (info: { columnIndex: number }) => number;\n  getRowHeight?: (info: { rowIndex: number }) => number;\n  renderCell: (info: { columnIndex: number; rowIndex: number }) => ReactNode;\n}) {\n  const view = useRef<View>(null);\n  const [layoutCount, setLayoutCount] = useState(0);\n  const virtualColumns = useRef<ColumnObject[]>([]);\n  const virtualRows = useRef<RowObject[]>([]);\n  const virtualCells = useRef<CellObject[]>([]);\n\n  /**\n   * 左上角的坐标\n   */\n  const coordinate = useRef(new Animated.ValueXY({ x: 0, y: 0 }));\n  const containerSize = useRef(new Animated.ValueXY({ x: 0, y: 0 }));\n\n  /**\n   * 获取当前的rowIndex范围和columnIndex范围\n   */\n  const getRange = useCallback(() => {\n    let minColumn = virtualColumns.current[0];\n    let maxColumn = virtualColumns.current[0];\n    let minRow = virtualRows.current[0];\n    let maxRow = virtualRows.current[0];\n\n    for (let i = 0; i < virtualColumns.current.length; i++) {\n      const column = virtualColumns.current[i];\n      if (column.columnIndex < minColumn.columnIndex) {\n        minColumn = column;\n      }\n      if (column.columnIndex > maxColumn.columnIndex) {\n        maxColumn = column;\n      }\n    }\n\n    for (let i = 0; i < virtualRows.current.length; i++) {\n      const row = virtualRows.current[i];\n      if (row.rowIndex < minRow.rowIndex) {\n        minRow = row;\n      }\n      if (row.rowIndex > maxRow.rowIndex) {\n        maxRow = row;\n      }\n    }\n    return { minColumn, minRow, maxColumn, maxRow };\n  }, []);\n\n  /**\n   * init containerSize, virtualColumns, virtualRows\n   */\n  const onContainerLayout = useCallback(\n    (event) => {\n      const { layout } = event.nativeEvent;\n      containerSize.current.setValue({ x: layout.width, y: layout.height });\n\n      let virtualColumnsTotalWidth = 0;\n      let virtualRowsTotalHeight = 0;\n\n      for (const column of virtualColumns.current) {\n        virtualColumnsTotalWidth += column.width;\n      }\n      for (const row of virtualRows.current) {\n        virtualRowsTotalHeight += row.height;\n      }\n\n      const { maxRow, maxColumn } = getRange();\n\n      /**\n       * 填满virtualRows和virtualColumns\n       */\n      let rowIndex = maxRow?.rowIndex ?? -1;\n      while (virtualRowsTotalHeight < layout.height) {\n        rowIndex++;\n        const rowHeight = getRowHeight({ rowIndex });\n        virtualRowsTotalHeight += rowHeight;\n        if (virtualRows.current.length === 0) {\n          virtualRows.current.push(\n            new RowObject({\n              y: 0,\n              height: rowHeight,\n              rowIndex,\n            })\n          );\n        } else {\n          const prev = virtualRows.current[virtualRows.current.length - 1];\n          virtualRows.current.push(\n            new RowObject({\n              y: prev.y + prev.height,\n              height: rowHeight,\n              rowIndex,\n            })\n          );\n        }\n      }\n      let columnIndex = maxColumn?.columnIndex ?? -1;\n      while (virtualColumnsTotalWidth < layout.width) {\n        columnIndex++;\n        const columnWidth = getColumnWidth({ columnIndex });\n        virtualColumnsTotalWidth += columnWidth;\n        if (virtualColumns.current.length === 0) {\n          virtualColumns.current.push(\n            new ColumnObject({\n              x: 0,\n              width: columnWidth,\n              columnIndex,\n            })\n          );\n        } else {\n          const prev =\n            virtualColumns.current[virtualColumns.current.length - 1];\n          virtualColumns.current.push(\n            new ColumnObject({\n              width: columnWidth,\n              x: prev.x + prev.width,\n              columnIndex,\n            })\n          );\n        }\n      }\n\n      /**\n       * 增加额外的column和row\n       */\n      rowIndex++;\n      const rowHeight = getRowHeight({ rowIndex });\n      const prevRow = virtualRows.current[virtualRows.current.length - 1];\n      virtualRows.current.push(\n        new RowObject({\n          y: prevRow.y + prevRow.height,\n          height: rowHeight,\n          rowIndex,\n        })\n      );\n      columnIndex++;\n      const prevColumn =\n        virtualColumns.current[virtualColumns.current.length - 1];\n      const columnWidth = getColumnWidth({ columnIndex });\n      virtualColumns.current.push(\n        new ColumnObject({\n          width: columnWidth,\n          x: prevColumn.x + prevColumn.width,\n          columnIndex,\n        })\n      );\n\n      /**\n       * 重置cells\n       * cells的数量是 (rowCount+1) * (columnCount+1)，因为\n       * 会出现左边的cell还没消失\n       */\n      virtualCells.current = [];\n      for (let i = 0; i < virtualRows.current.length; i++) {\n        const row = virtualRows.current[i];\n        for (let j = 0; j < virtualColumns.current.length; j++) {\n          const column = virtualColumns.current[j];\n          virtualCells.current.push(\n            new CellObject({\n              column,\n              row,\n            })\n          );\n        }\n      }\n\n      setLayoutCount((prev) => prev + 1);\n    },\n    [getColumnWidth, getRowHeight, getRange]\n  );\n\n  const updateCoordinate = useCallback(\n    (event: { deltaX: number; deltaY: number }) => {\n      const { x, y } = JSON.parse(JSON.stringify(coordinate.current));\n      const { x: containerWidth, y: containerHeight } = JSON.parse(\n        JSON.stringify(containerSize.current)\n      );\n\n      /**\n       * 如果移动过快，超过了逐次迁移元素的速度，那么拆分成多次操作，重复\n       * 调用updateCoordinate\n       */\n      let shouldSplitAction = false;\n      const splitAction = { deltaX: 0, deltaY: 0 };\n\n      /**\n       * (1/5)\n       * 获取当前的rowIndex范围和columnIndex范围\n       * 如果现在已经到最左边column或最右边column了，那就不再继续移动column，\n       * 同时coordinate.x最小值不能小于 containerWidth - (maxColumn.x+column.width)\n       * 也就是说coordinate.x区间是：[containerWidth - (maxColumn.x+column.width), 0]\n       *\n       * row同理\n       */\n      let { minColumn, maxColumn, minRow, maxRow } = getRange();\n\n      /**\n       * (2/5)\n       * 计算出minX,minY\n       * 根据deltaX位移计算需要展示的column,\n       * 逐个通过消耗deltaX，通过getColumnWidth获取宽度，直到deltaX额度用完\n       * 1. 判断maxColumn是否已经完全展示，\n       *    a. 未完全展示：deltaX -= maxColumn未完全展示的部分(deltaX等于0结束)\n       *       nextX -= maxColumn未完全展示的部分；-> 2\n       *    b. 完全展示：-> 2\n       * 2. 获取下一个maxColumn，判断deltaX剩余额度是否大于maxColumn宽度\n       *    a. 大于: deltaX -= maxColumn宽度，\n       *            nextX -= maxColumn宽度，-> 2\n       *    b. 小于等于：结束\n       *\n       * deltaY同理\n       *\n       * deltaX > 0 左移\n       * deltaX < 0 右移\n       * deltaY > 0 上移\n       * deltaY < 0 下移\n       */\n\n      let deltaX = event.deltaX;\n      let deltaY = event.deltaY;\n      let finalMaxColumnIndex = maxColumn.columnIndex;\n      let deltaX0 = maxColumn.x + maxColumn.width + x - containerWidth;\n      let finalMaxRowIndex = maxRow.rowIndex;\n      let deltaY0 = maxRow.y + maxRow.height + y - containerHeight;\n\n      // 左移补尾\n      if (deltaX > 0) {\n        while (deltaX > deltaX0) {\n          if (finalMaxColumnIndex === columnCount) {\n            break;\n          }\n          finalMaxColumnIndex++;\n          if (\n            finalMaxColumnIndex - maxColumn.columnIndex >=\n            virtualColumns.current.length - 2\n          ) {\n            shouldSplitAction = true;\n            break;\n          }\n          const maxColumnWidth = getColumnWidth({\n            columnIndex: finalMaxColumnIndex,\n          });\n          deltaX0 += maxColumnWidth;\n        }\n        deltaX = Math.min(deltaX0, deltaX);\n        if (shouldSplitAction) {\n          splitAction.deltaX = event.deltaX - deltaX;\n        }\n      }\n      if (deltaY > 0) {\n        while (deltaY > deltaY0) {\n          if (finalMaxRowIndex === rowCount) {\n            break;\n          }\n          finalMaxRowIndex++;\n          if (\n            finalMaxRowIndex - maxRow.rowIndex >=\n            virtualRows.current.length - 2\n          ) {\n            shouldSplitAction = true;\n            break;\n          }\n          const maxRowHeight = getRowHeight({\n            rowIndex: finalMaxRowIndex,\n          });\n          deltaY0 += maxRowHeight;\n        }\n        deltaY = Math.min(deltaY0, deltaY);\n        if (shouldSplitAction) {\n          splitAction.deltaY = event.deltaY - deltaY;\n        }\n      }\n\n      /**\n       * (3/5)\n       * 更新左上角坐标，其他所有位置都依据这个坐标进行位移\n       * x值区间：[containerWidth - contentWidth, 0]\n       * y值区间：[containerHeight - contentHeight, 0]\n       */\n      if (x - deltaX > 0) {\n        deltaX = x;\n      }\n      if (y - deltaY > 0) {\n        deltaY = y;\n      }\n\n      const nextX = x - deltaX;\n      const nextY = y - deltaY;\n\n      coordinate.current.setValue({\n        x: nextX,\n        y: nextY,\n      });\n\n      /**\n       * (4/5)\n       * 更新virtualColumns和virtualRows\n       * 如果deltaX > 0 (往左边移), 将最左边在可视范围外的columns依次移动到末尾\n       * 如果deltaX < 0（往右边移）, 将最右边在可视范围外的columns倒序依次移动到头部\n       * rows同理。\n       */\n      const outsideColumns: ColumnObject[] = [];\n      const outsideRows: RowObject[] = [];\n      const outsideCells: CellObject[] = [];\n\n      // 左移，在末尾增加\n      if (deltaX > 0) {\n        for (let i = 0; i < virtualColumns.current.length; i++) {\n          const column = virtualColumns.current[i];\n\n          /**\n           * 判断超出范围的依据是列的*右侧*小于0\n           */\n          const isOutOfView = column.x + nextX + column.width < 0;\n          if (isOutOfView) {\n            outsideColumns.push(column);\n          }\n        }\n\n        /**\n         * 所有column均已超出屏幕，此时根据finalMaxIndex重新计算\n         * 所有的column的位置\n         */\n\n        if (outsideColumns.length === virtualColumns.current.length) {\n          console.error(\"This shoud not happen\");\n        }\n        // console.log({ outsideColumns, maxColumnValue });\n        if (outsideColumns.length > 0) {\n          for (let i = 0; i < outsideColumns.length; i++) {\n            /**\n             * 先更新columnIndex\n             * 通过columnIndex拿到columnWidth\n             * 再更新maxColumnValue以供下一个column使用\n             */\n            const column = outsideColumns[i];\n            column.xAnimated.setValue(maxColumn.x + maxColumn.width);\n            column.columnIndex = maxColumn.columnIndex + 1;\n            const columnWidth = getColumnWidth(column);\n            column.widthAnimated.setValue(columnWidth);\n            maxColumn = column;\n          }\n        }\n      }\n\n      // 右移，在头部增加\n      if (deltaX < 0) {\n        for (let i = 0; i < virtualColumns.current.length; i++) {\n          const column = virtualColumns.current[i];\n          const columnValue = column.x;\n\n          /**\n           * 判断超出范围的依据是列的*左侧*大于containerWidth\n           */\n          const isOutOfView = columnValue + nextX > containerWidth;\n          if (isOutOfView) {\n            outsideColumns.unshift(column);\n          }\n        }\n        // console.log({ outsideColumns, minColumnValue });\n        if (outsideColumns.length > 0) {\n          for (let i = 0; i < outsideColumns.length; i++) {\n            if (minColumn.columnIndex === 0) {\n              break;\n            }\n            /**\n             * 先更新columnIndex\n             * 通过columnIndex拿到columnWidth\n             * 再更新minColumnValue以供下一个column使用\n             */\n            const column = outsideColumns[i];\n            column.columnIndex = minColumn.columnIndex - 1;\n            const columnWidth = getColumnWidth(column);\n            column.widthAnimated.setValue(columnWidth);\n            column.xAnimated.setValue(minColumn.x - columnWidth);\n            minColumn = column;\n          }\n        }\n      }\n\n      // 上移，在尾部增加\n      if (deltaY > 0) {\n        for (let i = 0; i < virtualRows.current.length; i++) {\n          const row = virtualRows.current[i];\n\n          /**\n           * 判断超出范围的依据是行的*下侧*小于0\n           */\n          const isOutOfView = row.y + nextY + row.height < 0;\n          if (isOutOfView) {\n            outsideRows.push(row);\n          }\n        }\n\n        // console.log(outsideRows);\n        // console.log({ outsideRows, maxRowValue });\n        /**\n         * 所有column均已超出屏幕，此时根据finalMaxIndex重新计算\n         * 所有的column的位置\n         */\n        if (outsideRows.length === virtualRows.current.length) {\n          console.error(\"Warning: This shoud not happen\");\n        }\n\n        if (outsideRows.length > 0) {\n          for (let i = 0; i < outsideRows.length; i++) {\n            const row = outsideRows[i];\n            row.rowIndex = maxRow.rowIndex + 1;\n            row.yAnimated.setValue(maxRow.y + maxRow.height);\n            const rowHeight = getRowHeight(row);\n            row.heightAnimated.setValue(rowHeight);\n            maxRow = row;\n          }\n        }\n      }\n\n      // 下移，在头部增加\n      if (deltaY < 0) {\n        for (let i = 0; i < virtualRows.current.length; i++) {\n          const row = virtualRows.current[i];\n\n          /**\n           * 判断超出范围的依据是行的*上侧*大于容器高度\n           */\n          const isOutOfView = row.y + nextY > containerHeight;\n          if (isOutOfView) {\n            outsideRows.unshift(row);\n          }\n        }\n        // console.log({ outsideRows, minRowValue });\n        if (outsideRows.length > 0) {\n          for (let i = 0; i < outsideRows.length; i++) {\n            if (minRow.rowIndex === 0) {\n              break;\n            }\n            const row = outsideRows[i];\n            row.rowIndex = minRow.rowIndex - 1;\n            const rowHeight = getRowHeight(row);\n            row.heightAnimated.setValue(rowHeight);\n            row.yAnimated.setValue(minRow.y - row.height);\n            minRow = row;\n          }\n        }\n      }\n\n      /**\n       * (5/5)\n       * 计算需要更新的cell，并调用update方法更新cell\n       */\n      for (let i = 0; i < virtualCells.current.length; i++) {\n        const cell = virtualCells.current[i];\n        if (!outsideCells.includes(cell)) {\n          if (outsideColumns.includes(cell.column)) {\n            outsideCells.push(cell);\n          } else if (outsideRows.includes(cell.row)) {\n            outsideCells.push(cell);\n          }\n        }\n      }\n\n      if (!shouldSplitAction) {\n        for (const cell of outsideCells) {\n          cell.ref.current.update({\n            rowIndex: cell.row.rowIndex,\n            columnIndex: cell.column.columnIndex,\n          });\n        }\n      }\n\n      // 继续未完成action\n      if (shouldSplitAction) {\n        if (__DEV__) {\n          console.log(\"splitAction\", splitAction);\n        }\n        requestAnimationFrame(() => {\n          updateCoordinate(splitAction);\n        });\n      }\n    },\n    [getColumnWidth, getRange, columnCount, rowCount, getRowHeight]\n  );\n\n  const onWheel = useCallback(\n    (event) => {\n      const { deltaX, deltaY } = event;\n      updateCoordinate({ deltaX, deltaY });\n    },\n    [updateCoordinate]\n  );\n\n  useEffect(() => {\n    if (Platform.OS === \"web\") {\n      const el = view.current as any;\n\n      el.addEventListener(\"wheel\", onWheel);\n      return () => {\n        el.removeEventListener(\"wheel\", onWheel);\n      };\n    }\n  }, [onWheel]);\n\n  return (\n    <View\n      ref={view}\n      style={[style, { overflow: \"hidden\" }]}\n      onLayout={onContainerLayout}\n    >\n      {showColumnLine && (\n        <Fragment key={`columns-${layoutCount}`}>\n          {virtualColumns.current.map((column, index) => {\n            return (\n              <Animated.View\n                key={index}\n                style={{\n                  position: \"absolute\",\n                  width: 1,\n                  backgroundColor: \"#ccc\",\n                  transform: [\n                    {\n                      translateX: Animated.add(\n                        column.xAnimated,\n                        coordinate.current.x\n                      ),\n                    },\n                  ],\n                  height: containerSize.current.y,\n                }}\n              />\n            );\n          })}\n        </Fragment>\n      )}\n      {showRowLine && (\n        <Fragment key={`rows-${layoutCount}`}>\n          {virtualRows.current.map((row, index) => {\n            return (\n              <Animated.View\n                key={index}\n                style={{\n                  position: \"absolute\",\n                  backgroundColor: \"#ccc\",\n                  transform: [\n                    {\n                      translateY: Animated.add(\n                        row.yAnimated,\n                        coordinate.current.y\n                      ),\n                    },\n                  ],\n                  width: containerSize.current.x,\n                  height: 1,\n                }}\n              />\n            );\n          })}\n        </Fragment>\n      )}\n      <Fragment key={`cells-${layoutCount}`}>\n        {virtualCells.current.map((cell, index) => {\n          return (\n            <Cell\n              coordinate={coordinate.current}\n              ref={cell.ref}\n              key={index}\n              column={cell.column}\n              row={cell.row}\n              renderCell={renderCell}\n            />\n          );\n        })}\n      </Fragment>\n    </View>\n  );\n}\n","import React, {\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport {\n  Animated,\n  Platform,\n  SafeAreaView,\n  Text,\n  TouchableOpacity,\n  useWindowDimensions,\n  View,\n} from \"react-native\";\n\nimport { VirtualizedGrid } from \"./src/index\";\n\nexport default function App() {\n  const { width, height } = useWindowDimensions();\n  return (\n    <VirtualizedGrid\n      columnCount={Number.MAX_SAFE_INTEGER}\n      rowCount={Number.MAX_SAFE_INTEGER}\n      style={{\n        borderWidth: 1,\n        borderColor: \"#000\",\n        width,\n        height,\n      }}\n      getColumnWidth={(info: { columnIndex: number }) => {\n        return [100, 140, 200, 120][info.columnIndex % 4];\n      }}\n      getRowHeight={(info: { rowIndex: number }) => {\n        return [40, 50, 60, 90, 40, 45, 40, 50, 55, 50, 60][info.rowIndex % 10];\n      }}\n      renderCell={(info) => {\n        return (\n          <View\n            style={{\n              flex: 1,\n              backgroundColor:\n                (info.rowIndex + info.columnIndex) % 2 === 1 ? \"#eee\" : \"#fff\",\n              borderTopWidth: 1,\n              borderLeftWidth: 1,\n              borderColor: \"#ccc\",\n              padding: 4,\n            }}\n          >\n            <Text>c: {info.columnIndex}</Text>\n            <Text>r: {info.rowIndex}</Text>\n          </View>\n        );\n      }}\n    />\n  );\n}\n"],"sourceRoot":""}